import logging
from datetime import datetime
from django.db.models import F, Count, Sum
from django.http import HttpResponse
from django.utils import timezone
from rest_framework import status, permissions, generics
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.throttling import AnonRateThrottle, UserRateThrottle
from rest_framework.pagination import PageNumberPagination
from rest_framework_simplejwt.views import TokenObtainPairView

from .models import Page, AdminUser
from .serializers import (
    PageRequestSerializer, 
    PageResponseSerializer, 
    AdminUserSerializer,
    AdminDashboardStatsSerializer,
    CustomTokenObtainPairSerializer
)
from .services import GenericPageService

logger = logging.getLogger(__name__)

# ==========================================================
# PAGINATION
# ==========================================================
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

# ==========================================================
# PUBLIC ENDPOINTS
# ==========================================================
class GeneratePageView(APIView):
    """
    Public endpoint to generate a new page.
    Throttled: 10/day for anon, more for users.
    """
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]

    def post(self, request):
        serializer = PageRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            page = GenericPageService.generate_page(
                email=serializer.validated_data['email'],
                prompt=serializer.validated_data['prompt'],
                page_type=serializer.validated_data.get('page_type', 'other'),
                theme=serializer.validated_data.get('theme', 'modern')
            )
            response_serializer = PageResponseSerializer(page, context={'request': request})
            return Response(response_serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Generation error: {str(e)}", exc_info=True)
            return Response(
                {'error': 'An internal error occurred during generation.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class LivePageView(APIView):
    """
    Serves the raw HTML content for a generated page.
    Increments view count.
    """
    permission_classes = [permissions.AllowAny]

    def get(self, request, page_id):
        # We use active_objects to respect soft deletes
        try:
            page = Page.active_objects.get(id=page_id)
        except Page.DoesNotExist:
            return HttpResponse("Page not found", status=404)
        
        # Atomically increment view count
        Page.objects.filter(id=page_id).update(view_count=F('view_count') + 1)
        
        return HttpResponse(page.html_content, content_type='text/html')


class UserHistoryView(generics.ListAPIView):
    """
    Returns history of pages generated by an email.
    Supports pagination.
    """
    permission_classes = [permissions.AllowAny]
    serializer_class = PageResponseSerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        email = self.request.query_params.get('email')
        if not email:
            return Page.active_objects.none()
        return Page.active_objects.filter(email=email).order_by('-created_at')

    def list(self, request, *args, **kwargs):
        email = request.query_params.get('email')
        if not email:
            return Response({'error': 'Email parameter required'}, status=status.HTTP_400_BAD_REQUEST)
        return super().list(request, *args, **kwargs)


# ==========================================================
# ADMIN & AUTH ENDPOINTS
# ==========================================================
class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Custom login view that accepts either email or username.
    """
    serializer_class = CustomTokenObtainPairSerializer


from rest_framework_simplejwt.tokens import RefreshToken

class AdminRegisterView(generics.CreateAPIView):
    """
    Public endpoint for initial admin registration.
    Returns user data AND tokens for immediate login.
    """
    permission_classes = [permissions.AllowAny]
    queryset = AdminUser.objects.all()
    serializer_class = AdminUserSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Prepare response data
        headers = self.get_success_headers(serializer.data)
        response_data = {
            'user': serializer.data,
            'token': str(refresh.access_token),
            'refreshToken': str(refresh),
        }
        
        return Response(response_data, status=status.HTTP_201_CREATED, headers=headers)


class AdminDashboardView(APIView):
    """
    Restricted admin dashboard view with detailed analytics.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        today = timezone.now().date()
        
        # Stats
        stats_data = {
            'totalPages': Page.active_objects.count(),
            'pagesToday': Page.active_objects.filter(created_at__date=today).count(),
            'totalViews': Page.active_objects.aggregate(total=Sum('view_count'))['total'] or 0,
            'uniqueUsers': Page.active_objects.values('email').distinct().count(),
        }
        
        # Popular Types
        popular_types = Page.active_objects.values('page_type').annotate(
            count=Count('id')
        ).order_by('-count')[:5]
        
        total = stats_data['totalPages']
        popular_formatted = [
            {
                'type': item['page_type'],
                'count': item['count'],
                'percentage': int((item['count'] / total) * 100) if total > 0 else 0
            } for item in popular_types
        ]
        
        # Recent activity
        recent_pages = Page.active_objects.order_by('-created_at')[:10]
        recent_serializer = PageResponseSerializer(recent_pages, many=True, context={'request': request})
        
        return Response({
            'stats': stats_data,
            'popularTypes': popular_formatted,
            'recentPages': recent_serializer.data
        })


class AdminMeView(APIView):
    """
    Returns the current authenticated user's details.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = AdminUserSerializer(request.user)
        return Response({'user': serializer.data})
