import logging
import requests
from datetime import datetime
from django.conf import settings
from django.db.models import F, Count, Sum
from django.http import HttpResponse
from django.utils import timezone
from rest_framework import status, permissions, generics
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.throttling import AnonRateThrottle, UserRateThrottle
from rest_framework.pagination import PageNumberPagination
from rest_framework_simplejwt.views import TokenObtainPairView

from .models import Page, AdminUser
from .serializers import (
    PageRequestSerializer, 
    PageResponseSerializer, 
    AdminUserSerializer,
    AdminDashboardStatsSerializer,
    CustomTokenObtainPairSerializer
)
from .services import GenericPageService

logger = logging.getLogger(__name__)

# ==========================================================
# PAGINATION
# ==========================================================
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

# ==========================================================
# PUBLIC ENDPOINTS
# ==========================================================
class GeneratePageView(APIView):
    """
    Public endpoint to generate a new page.
    Throttled: 10/day for anon, more for users.
    """
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]

    def post(self, request):
        serializer = PageRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            page = GenericPageService.generate_page(
                email=serializer.validated_data['email'],
                prompt=serializer.validated_data['prompt'],
                page_type=serializer.validated_data.get('page_type', 'other'),
                theme=serializer.validated_data.get('theme', 'modern'),
                user_data=serializer.validated_data.get('user_data')
            )
            response_serializer = PageResponseSerializer(page, context={'request': request})
            return Response(response_serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Generation error: {str(e)}", exc_info=True)
            return Response(
                {'error': 'An internal error occurred during generation.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class LivePageView(APIView):
    """
    Serves the raw HTML content for a generated page.
    Increments view count.
    """
    permission_classes = [permissions.AllowAny]

    def get(self, request, page_id):
        # We use active_objects to respect soft deletes
        try:
            page = Page.active_objects.get(id=page_id)
        except Page.DoesNotExist:
            return HttpResponse("Page not found", status=404)
        
        # Atomically increment view count
        Page.objects.filter(id=page_id).update(view_count=F('view_count') + 1)
        
        return HttpResponse(page.html_content, content_type='text/html')


class UserHistoryView(generics.ListAPIView):
    """
    Returns history of pages generated by an email.
    Supports pagination.
    """
    permission_classes = [permissions.AllowAny]
    serializer_class = PageResponseSerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        email = self.request.query_params.get('email')
        if not email:
            return Page.active_objects.none()
        return Page.active_objects.filter(email=email).order_by('-created_at')

    def list(self, request, *args, **kwargs):
        email = request.query_params.get('email')
        if not email:
            return Response({'error': 'Email parameter required'}, status=status.HTTP_400_BAD_REQUEST)
        return super().list(request, *args, **kwargs)


# ==========================================================
# ADMIN & AUTH ENDPOINTS
# ==========================================================
class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Custom login view that accepts either email or username.
    """
    serializer_class = CustomTokenObtainPairSerializer


from rest_framework_simplejwt.tokens import RefreshToken

class AdminRegisterView(generics.CreateAPIView):
    """
    Public endpoint for initial admin registration.
    Returns user data AND tokens for immediate login.
    """
    permission_classes = [permissions.AllowAny]
    queryset = AdminUser.objects.all()
    serializer_class = AdminUserSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Prepare response data
        headers = self.get_success_headers(serializer.data)
        response_data = {
            'user': serializer.data,
            'token': str(refresh.access_token),
            'refreshToken': str(refresh),
        }
        
        return Response(response_data, status=status.HTTP_201_CREATED, headers=headers)


class AdminDashboardView(APIView):
    """
    Restricted admin dashboard view with detailed analytics.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        today = timezone.now().date()
        
        # Stats
        stats_data = {
            'totalPages': Page.active_objects.count(),
            'pagesToday': Page.active_objects.filter(created_at__date=today).count(),
            'totalViews': Page.active_objects.aggregate(total=Sum('view_count'))['total'] or 0,
            'uniqueUsers': Page.active_objects.values('email').distinct().count(),
        }
        
        # Popular Types
        popular_types = Page.active_objects.values('page_type').annotate(
            count=Count('id')
        ).order_by('-count')[:5]
        
        total = stats_data['totalPages']
        popular_formatted = [
            {
                'type': item['page_type'],
                'count': item['count'],
                'percentage': int((item['count'] / total) * 100) if total > 0 else 0
            } for item in popular_types
        ]
        
        # Recent activity
        recent_pages = Page.active_objects.order_by('-created_at')[:10]
        recent_serializer = PageResponseSerializer(recent_pages, many=True, context={'request': request})
        
        return Response({
            'stats': stats_data,
            'popularTypes': popular_formatted,
            'recentPages': recent_serializer.data
        })


class GeneratePromptView(APIView):
    """
    Generate an AI-optimized prompt from structured user data.
    This endpoint is called before final page generation to show users the prompt.
    """
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]

    def post(self, request):
        from .serializers import GeneratePromptRequestSerializer, GeneratePromptResponseSerializer
        
        serializer = GeneratePromptRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        user_data = serializer.validated_data['user_data']
        
        try:
            # Use AI to generate an optimized prompt from the user data
            generated_prompt = self._generate_prompt_with_ai(user_data)
            
            response_serializer = GeneratePromptResponseSerializer({
                'generated_prompt': generated_prompt,
                'user_data': user_data
            })
            
            return Response(response_serializer.data, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Prompt generation error: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Failed to generate prompt. Please try again.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _generate_prompt_with_ai(self, user_data):
        """Use Groq AI to generate an optimized prompt from user data"""
        
        # Extract key information
        sub_type = user_data.get('sub_type', 'wishes')
        title = user_data.get('title', '')
        theme = user_data.get('theme', 'modern')
        font = user_data.get('font', 'sans')
        
        # Determine intent for the meta-prompt
        specific_fields = user_data.get('specific_fields', {})
        gender = specific_fields.get('gender', 'Neutral')
        color_intent = f"appropriate for {gender} (e.g., {'Pink/Pastel' if gender == 'Female' else 'Blue/Corporate' if gender == 'Male' else 'Vibrant/Neutral'})"

        if sub_type == 'wishes':
            page_intent = "Birthday Wishes"
            intent_context = f"emotional, heart-centered birthday wish page with expressive visuals and colors {color_intent}"
            layer2_flexible = """1. **Rhythm Softening**: Introduce neutral contrast sections between high-energy blocks.
2. **Story Section**: Focus the message section on the relationship and shared memories.
3. **Emotional Closure**: Footer MUST be a warm, memorable send-off reinforcing the birthday spirit."""
        else: # Default to invitation if not wishes
            page_intent = "Birthday Invitation"
            intent_context = f"clear, informative birthday invitation page focusing on Date, Time, and Venue, with colors {color_intent}"
            layer2_flexible = """1. **Rhythm Softening**: Introduce neutral contrast sections between high-energy blocks.
2. **RSVP Urgency**: Primary CTA MUST have an urgency cue below (e.g., 'RSVP by...'). 
3. **Event Focus**: Ensure Date, Time, and Location are the most scannable elements.
4. **Emotional Closure**: Footer MUST be a warm, memorable send-off reinforcing the birthday spirit."""

        # Create a meta-prompt for the AI to generate the actual prompt
        meta_prompt = f"""You are a professional prompt engineer. Generate a highly detailed, optimized prompt for creating a stunning {page_intent} web page.

User Requirements:
- Page Intent: {page_intent} ({intent_context})
- Birthday Person Gender: {gender}
- Page Title: {title}
- Theme: {theme}
- Font Style: {font}

User Data:
{self._format_user_data(user_data)}

Generate a professional, structured prompt for an expert frontend engineer to build a high-quality {page_intent} page. 

The prompt MUST be divided into two layers:

**Layer 1: Engineering & Emotional Contract (LOCKED)**
1. **Clean Code & Font Policy**: Use ONLY valid Tailwind colors. PROHIBITED: inventing font utility classes. Use inline styles for custom script fonts. 
2. **Scannability**: Make Labels (Date:, Location:) bold/dark vs Regular Values. Structure as 'Label: Value'.
3. **Hero & Message Identity**: Hero MUST include an elegant headline + adult subtitle. Special Message must have its own header and a neutral/soft background.
4. **Content Safety & Tone**: NEVER output gibberish. Use deeply personal narrative framing.

**Layer 2: Visual Rhythm & Impact (FLEXIBLE)**
{layer2_flexible}
5. **Accessibility**: Ensure high contrast for all elements.

Output ONLY the prompt text (600-800 words). Ensure technical accuracy and deeply personal storytelling.
"""

        # Call Groq AI
        payload = {
            "model": settings.GROQ_PROMPT_MODEL,
            "messages": [
                {"role": "system", "content": "You are an expert prompt engineer who creates detailed, effective prompts for generating beautiful, professional web pages. You specialize in Tailwind CSS and modern UI/UX design."},
                {"role": "user", "content": meta_prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 2500
        }

        headers = {
            "Authorization": f"Bearer {settings.GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        try:
            response = requests.post(
                "https://api.groq.com/openai/v1/chat/completions",
                json=payload,
                headers=headers,
                timeout=60
            )
            response.raise_for_status()
            
            data = response.json()
            if "choices" not in data or not data["choices"]:
                raise ValueError("Invalid AI response")
            
            generated_prompt = data["choices"][0]["message"]["content"].strip()
            logger.info(f"AI-generated prompt length: {len(generated_prompt)} chars")
            
            return generated_prompt
            
        except requests.exceptions.HTTPError as e:
            logger.error(f"AI prompt generation failed: {str(e)}")
            logger.error(f"Response content: {e.response.text if hasattr(e, 'response') else 'No response'}")
            raise ValueError(f"OpenRouter API error: {str(e)}")
        except Exception as e:
            logger.error(f"AI prompt generation failed: {str(e)}")
            raise
    
    def _format_user_data(self, user_data):
        """Format user data for display in meta-prompt"""
        lines = []
        exclude_keys = ['occasion', 'email', 'theme', 'title', 'specific_fields', 'font', 'language', 'color', 'generatedPrompt', 'prompt']
        
        for key, value in user_data.items():
            if key not in exclude_keys and value:
                readable_key = key.replace('_', ' ').title()
                lines.append(f"- {readable_key}: {value}")
        
        # Add specific fields
        specific_fields = user_data.get('specific_fields', {})
        if specific_fields:
            lines.append("\nOccasion-Specific Details:")
            for key, value in specific_fields.items():
                if value and value != 'undefined':
                    readable_key = key.replace('_', ' ').title()
                    lines.append(f"- {readable_key}: {value}")
        
        return '\n'.join(lines) if lines else "No additional details provided"


class AdminMeView(APIView):
    """
    Returns the current authenticated user's details.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = AdminUserSerializer(request.user)
        return Response({'user': serializer.data})
