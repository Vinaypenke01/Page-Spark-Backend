import logging
import requests
from datetime import datetime
from django.conf import settings
from django.db.models import F, Count, Sum
from django.http import HttpResponse
from django.utils import timezone
from rest_framework import status, permissions, generics
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.throttling import AnonRateThrottle, UserRateThrottle
from rest_framework.pagination import PageNumberPagination
from rest_framework_simplejwt.views import TokenObtainPairView

from .models import Page, AdminUser
from .serializers import (
    PageRequestSerializer, 
    PageResponseSerializer, 
    AdminUserSerializer,
    AdminDashboardStatsSerializer,
    CustomTokenObtainPairSerializer
)
from .services import GenericPageService

logger = logging.getLogger(__name__)

# ==========================================================
# PAGINATION
# ==========================================================
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

# ==========================================================
# PUBLIC ENDPOINTS
# ==========================================================
class GeneratePageView(APIView):
    """
    Public endpoint to generate a new page.
    Throttled: 10/day for anon, more for users.
    """
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]

    def post(self, request):
        serializer = PageRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            page = GenericPageService.generate_page(
                email=serializer.validated_data['email'],
                prompt=serializer.validated_data['prompt'],
                page_type=serializer.validated_data.get('page_type', 'other'),
                theme=serializer.validated_data.get('theme', 'modern'),
                user_data=serializer.validated_data.get('user_data')
            )
            response_serializer = PageResponseSerializer(page, context={'request': request})
            return Response(response_serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Generation error: {str(e)}", exc_info=True)
            return Response(
                {'error': 'An internal error occurred during generation.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class LivePageView(APIView):
    """
    Serves the raw HTML content for a generated page.
    Increments view count.
    """
    permission_classes = [permissions.AllowAny]

    def get(self, request, page_id):
        # We use active_objects to respect soft deletes
        try:
            page = Page.active_objects.get(id=page_id)
        except Page.DoesNotExist:
            return HttpResponse("Page not found", status=404)
        
        # Atomically increment view count
        Page.objects.filter(id=page_id).update(view_count=F('view_count') + 1)
        
        return HttpResponse(page.html_content, content_type='text/html')


class UserHistoryView(generics.ListAPIView):
    """
    Returns history of pages generated by an email.
    Supports pagination.
    """
    permission_classes = [permissions.AllowAny]
    serializer_class = PageResponseSerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        email = self.request.query_params.get('email')
        if not email:
            return Page.active_objects.none()
        return Page.active_objects.filter(email=email).order_by('-created_at')

    def list(self, request, *args, **kwargs):
        email = request.query_params.get('email')
        if not email:
            return Response({'error': 'Email parameter required'}, status=status.HTTP_400_BAD_REQUEST)
        return super().list(request, *args, **kwargs)


# ==========================================================
# ADMIN & AUTH ENDPOINTS
# ==========================================================
class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Custom login view that accepts either email or username.
    """
    serializer_class = CustomTokenObtainPairSerializer


from rest_framework_simplejwt.tokens import RefreshToken

class AdminRegisterView(generics.CreateAPIView):
    """
    Public endpoint for initial admin registration.
    Returns user data AND tokens for immediate login.
    """
    permission_classes = [permissions.AllowAny]
    queryset = AdminUser.objects.all()
    serializer_class = AdminUserSerializer

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Prepare response data
        headers = self.get_success_headers(serializer.data)
        response_data = {
            'user': serializer.data,
            'token': str(refresh.access_token),
            'refreshToken': str(refresh),
        }
        
        return Response(response_data, status=status.HTTP_201_CREATED, headers=headers)


class AdminDashboardView(APIView):
    """
    Restricted admin dashboard view with detailed analytics.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        today = timezone.now().date()
        
        # Stats
        stats_data = {
            'totalPages': Page.active_objects.count(),
            'pagesToday': Page.active_objects.filter(created_at__date=today).count(),
            'totalViews': Page.active_objects.aggregate(total=Sum('view_count'))['total'] or 0,
            'uniqueUsers': Page.active_objects.values('email').distinct().count(),
        }
        
        # Popular Types
        popular_types = Page.active_objects.values('page_type').annotate(
            count=Count('id')
        ).order_by('-count')[:5]
        
        total = stats_data['totalPages']
        popular_formatted = [
            {
                'type': item['page_type'],
                'count': item['count'],
                'percentage': int((item['count'] / total) * 100) if total > 0 else 0
            } for item in popular_types
        ]
        
        # Recent activity
        recent_pages = Page.active_objects.order_by('-created_at')[:10]
        recent_serializer = PageResponseSerializer(recent_pages, many=True, context={'request': request})
        
        return Response({
            'stats': stats_data,
            'popularTypes': popular_formatted,
            'recentPages': recent_serializer.data
        })


class GeneratePromptView(APIView):
    """
    Generate an AI-optimized prompt from structured user data.
    This endpoint is called before final page generation to show users the prompt.
    """
    permission_classes = [permissions.AllowAny]
    throttle_classes = [AnonRateThrottle]

    def post(self, request):
        from .serializers import GeneratePromptRequestSerializer, GeneratePromptResponseSerializer
        
        serializer = GeneratePromptRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        user_data = serializer.validated_data['user_data']
        
        try:
            # Use AI to generate an optimized prompt from the user data
            generated_prompt = self._generate_prompt_with_ai(user_data)
            
            response_serializer = GeneratePromptResponseSerializer({
                'generated_prompt': generated_prompt,
                'user_data': user_data
            })
            
            return Response(response_serializer.data, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Prompt generation error: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Failed to generate prompt. Please try again.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _generate_prompt_with_ai(self, user_data):
        """Use OpenRouter AI to generate an optimized prompt from user data"""
        
        # Extract key information
        occasion = user_data.get('occasion', 'generic').replace('_', ' ').title()
        title = user_data.get('title', '')
        theme = user_data.get('theme', 'modern')
        font = user_data.get('font', 'sans')
        
        # Create a meta-prompt for the AI to generate the actual prompt
        meta_prompt = f"""You are a professional prompt engineer specializing in web design. Generate a highly detailed, optimized prompt for creating a stunning {occasion} invitation web page.

User Requirements:
- Page Title: {title}
- Theme: {theme}
- Font Style: {font}
- Occasion: {occasion}

User Data:
{self._format_user_data(user_data)}

Generate a comprehensive, effective prompt that will result in a BEAUTIFUL, MODERN, and PROFESSIONAL web page. The prompt MUST include:

1. **Page Purpose & Context**
   - Clearly describe this is a {occasion} invitation page
   - Explain the target audience and desired emotional impact
   - Specify the overall tone (elegant, fun, professional, etc.)

2. **Visual Design Requirements** (CRITICAL - Be very specific)
   - Use a {theme} theme with a sophisticated color palette
   - Implement modern design trends: gradients, subtle shadows, smooth animations
   - Use {font} fonts with proper typography hierarchy
   - Include visual elements: decorative borders, icons, background patterns
   - Ensure generous white space and balanced layouts
   - Add hover effects and micro-interactions for engagement

3. **Tailwind CSS Implementation** (MANDATORY)
   - MUST include Tailwind CSS CDN link in the HTML
   - Use ONLY Tailwind utility classes for ALL styling
   - Specify exact Tailwind classes for: colors, spacing, typography, shadows, gradients
   - Examples: "bg-gradient-to-r from-purple-600 to-pink-600", "shadow-2xl", "hover:scale-105 transition-transform"
   - NO custom CSS or <style> tags allowed
   - Use Tailwind's responsive classes (sm:, md:, lg:, xl:)

4. **Layout & Structure**
   - Responsive design that works on mobile, tablet, and desktop
   - Clear visual hierarchy with hero section, details section, and call-to-action
   - Use Tailwind's flexbox/grid utilities for layouts
   - Include all user-provided details in an organized, visually appealing way

5. **Content Sections to Include**
   - Eye-catching header with title and decorative elements
   - Main content area with all event details
   - Visual separators between sections
   - Footer with additional information or RSVP details

6. **Technical Requirements**
   - Pure HTML with Tailwind CSS CDN
   - No JavaScript, no external images (use Tailwind's built-in features)
   - Semantic HTML5 elements
   - Accessible and SEO-friendly markup

7. **Quality Standards**
   - The page should look PREMIUM and PROFESSIONAL
   - Use vibrant, harmonious colors from Tailwind's palette
   - Implement smooth transitions and subtle animations
   - Ensure the design would impress users at first glance

Output a detailed, structured prompt (500-800 words) that an AI can follow to generate a stunning web page. Be VERY specific about Tailwind classes, colors, and design elements. The resulting page should be worthy of a professional designer's portfolio.

Output ONLY the prompt text, no explanations or meta-commentary."""

        # Call Groq AI
        payload = {
            "model": settings.GROQ_PROMPT_MODEL,
            "messages": [
                {"role": "system", "content": "You are an expert prompt engineer who creates detailed, effective prompts for generating beautiful, professional web pages. You specialize in Tailwind CSS and modern UI/UX design."},
                {"role": "user", "content": meta_prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 2500
        }

        headers = {
            "Authorization": f"Bearer {settings.GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        try:
            response = requests.post(
                "https://api.groq.com/openai/v1/chat/completions",
                json=payload,
                headers=headers,
                timeout=60
            )
            response.raise_for_status()
            
            data = response.json()
            if "choices" not in data or not data["choices"]:
                raise ValueError("Invalid AI response")
            
            generated_prompt = data["choices"][0]["message"]["content"].strip()
            logger.info(f"AI-generated prompt length: {len(generated_prompt)} chars")
            
            return generated_prompt
            
        except requests.exceptions.HTTPError as e:
            logger.error(f"AI prompt generation failed: {str(e)}")
            logger.error(f"Response content: {e.response.text if hasattr(e, 'response') else 'No response'}")
            raise ValueError(f"OpenRouter API error: {str(e)}")
        except Exception as e:
            logger.error(f"AI prompt generation failed: {str(e)}")
            raise
    
    def _format_user_data(self, user_data):
        """Format user data for display in meta-prompt"""
        lines = []
        exclude_keys = ['occasion', 'email', 'theme', 'title', 'specific_fields', 'font', 'language', 'color', 'generatedPrompt', 'prompt']
        
        for key, value in user_data.items():
            if key not in exclude_keys and value:
                readable_key = key.replace('_', ' ').title()
                lines.append(f"- {readable_key}: {value}")
        
        # Add specific fields
        specific_fields = user_data.get('specific_fields', {})
        if specific_fields:
            lines.append("\nOccasion-Specific Details:")
            for key, value in specific_fields.items():
                if value and value != 'undefined':
                    readable_key = key.replace('_', ' ').title()
                    lines.append(f"- {readable_key}: {value}")
        
        return '\n'.join(lines) if lines else "No additional details provided"


class AdminMeView(APIView):
    """
    Returns the current authenticated user's details.
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = AdminUserSerializer(request.user)
        return Response({'user': serializer.data})
